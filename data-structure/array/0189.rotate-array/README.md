[189. Rotate Array](https://leetcode.com/problems/rotate-array/)


### 思路
所谓的旋转，可以理解为将数组视为一个环，所有元素向后移动一位。
- 使用额外的数组
移动k次以后， 也就是 `newArray[(i+k)%size] = nums[i]`
如果不启用新的数组的话，可能会导致覆盖, 使用新的数组以后空间复杂度变成 O(n), 

- 环状替换
使用额外数组的原因在于如果我们直接将每个数字放至它最后的位置，这样被放置位置的元素会被覆盖从而丢失.
因此，从另一个角度，我们可以将被替换的元素保存在变量 temp 中，从而避免了额外数组的开销。
也就是说
1. 我们从位置 0 开始，最初令 temp=nums[0]。
2. 根据规则，位置 0 的元素会放至 (0+k) % size 的位置
   令 x=(0+k) % size，此时交换 temp 和 nums[x]，完成位置 x 的更新。
3. 然后，我们考察位置 x，并交换 temp 和 nums[(x+k) % n]，从而完成下一个位置的更新。
4. 不断进行上述过程，直至交换的次数等于 size。

- 不使用额外空间
通过**三次逆序**的方式来实现。
该方法基于如下的事实：当我们将数组的元素向右移动 k 次后，尾部 k % n 个元素会移动至数组头部，其余元素向后移动 k % n 个位置。

nums = "----->-->"; k =3
result = "-->----->";

reverse "----->-->" we can get "<--<-----"
reverse "<--" we can get "--><-----"
reverse "<-----" we can get "-->----->"

